# 包管理工具 npm & pnpm

## npm 

npm 是 nodejs 官方推荐的包管理工具，在安装 nodejs 时会自带安装 npm

- 1、registry : 镜像源
```sh
https://registry.npmjs.org/ : 官方镜像
http://registry.npmmirror.com : 淘宝镜像
http://mirrors.tencent.com/npm/ : 腾讯镜像

# 查看镜像
npm config get registry
# 全局设置镜像
npm config set registry http://registry.npmmirror.com
```
- 2、publish : 包发布

```sh
# 设置指定的镜像源，不设置会发布到 npm config get registry 的镜像源
alias tnpm="npm --registry https://xxx.xxxxx.com/"
# 登录
tnpm login
# 发布
tnpm publish
```

注意：package.json 中是否设置了 `private : "true"` ，如果有， 会有提示 `npm WARN publish Skipping workspace @xxx/xxx, marked as private。`

- 3、config : 配置
  
```sh
# 查看配置
npm config ls -l 
# 查看指定配置
npm config get xxx
# 设置指定配置
npm config set xxx xxxxx
```

- 4、prefix : npm install 安装包的 bin 的目录

```sh
npm config get prefix  
# /xxx/xxx/.nvm/versions/node/v20.14.0
# 如果 安装之后在终端仍然找不到命令，有可能是上面的结果，并没有加入到环境变了 $PATH 中
# 可以将上面路径加入到 PATH 中， 或者设置 prefix
npm config set prefix /usr/local
```

- 5、`.npmrc` : 项目根目录配置文件， 优先级更高，一般用于某个项目特定的配置
  
```sh
# 设置全局镜像源
registry=https://registry.npmmirror.com/ 
# 设置特定的包镜像源
@myscope:registry=https://mycustomregistry.example.org
```

- 6、cli ： 常用命令
  - `npm init` : 创建 package.json 文件
  - `npm install` : 安装指定包，或者安装所有依赖； 参数：`-D/-g` ； `uninstall` 卸载
  - `npm link` : 链接本地包，用于包开发调试，`unlink` 删除链接
  - `npm login` : 登录镜像源，`logout` 登出
  - `npm publish` : 发布包，`unpublish` 删除包
  - `npm prune` : 删除多余的包
  - `npm run` : 运行 package.json 中的 script 命令
  - `npx & npm exec` : 运行本地或者远程包命令，`npm exec` 功能较丰富，处理参数方式不一样
  ```sh
  npx foo@latest bar --package=@npmcli/foo
  # 不处理参数，相当于执行 foo bar --package=@npmcli/foo ; --package 交给 foo 处理
  npm exec foo@latest bar --package=@npmcli/foo
  # 先处理参数，再执行命令， 在 package=@npmcli/foo 环境下执行 foo bar
  ```

## PNPM

> 在 pnpm 之前一个简单的项目的 node_module 目录下有很多文件占据了很大的空间，很多的项目就给磁盘带来了压力。而且每次安装都是从远程拉取，也影响了安装速度。还有幽灵依赖（可以引入未在 package.json 中定义的包）的问题

- 1、优势 ： 通过软硬链接方式，极大优化了磁盘空间，安装速度，并解决幽灵依赖的问题。
  - node_module 中 使用软链保持平级。避免重复依赖
  - 下载的时候会优先从 缓存 store 中拉取，没有再网络下载

- 2、cli ：常用命令, 跟 npm 基本一样
  - `pnpm init` : 创建 package.json 文件
  - `pnpm install` : 安装所有依赖
  - `pnpm add` ：安装指定包； 参数： `-D / -g / -w（workspace）` ；删除 `remove rm un uninstall`
  - `pnpm link` : 链接本地包，用于包开发调试，`unlink` 删除链接
  - `pnpm import` ：从其他（package-lock.json ， yarn.lock）导入
  - `pnpm prune` ： 移除不需要的包
  - `pnpm fetch` ：用于 docker 镜像加速
  - `pnpm run` : 运行 package.json 中的 script 命令
  - `pnpm exec` : 执行 dependencies 的命令
  - `pnpm dlx == pnpx` : 执行远程命令

- 3、`.npmrc` 配置

```sh
# 设置全局镜像源
registry=https://registry.npmmirror.com/ 
# 设置特定的包镜像源
@myscope:registry=https://mycustomregistry.example.org
```

- 4、workspace
  
pnpm-workspace.yaml ：创建工作空间，用于 monorepo

```sh
packages:
  # all packages in direct subdirs of packages/
  - 'packages/*'
```

安装 workspace 其他的包 `pnpm add pkg2@workspace:^` 。package.json 文件中会多出一行 ` "pkg2": "workspace:^",`

- 5、`.pnpmfile.cjs`

提供了 hooks ，可以对 pnpm 的安装过程进行编程来实现特定需求。 比如一些复杂的旧系统升级改造，对某些包进行版本控制。

```js
module.exports = {
  hooks: {
    readPackage(pkg, context) {
      // 所有的包，如果依赖了 packageA ， 则把 packageA 的版本改为 '2.0.0'
      if (pkg.dependencies.packageA) {
        pkg.dependencies.packageA = '2.0.0';
      }
      // 如果 packageB 的版本是 1.x.x ，则把 packageB 的依赖的 packageC 的版本改为 '^3.0.0'
      if (pkg.name == 'packageB' && pkg.version.startsWith('1.')) {
        pkg.dependencies.packageC = '^3.0.0'
      }
      return packageJson;
    },
  },
};
```