# 正则表达式

> 正则表达式非常重要，几乎所有的语言都支持正则表达式，而且非常频繁出现在工作中，在复杂的匹配和检索中发挥巨大作用，有必要非常熟练掌握，

## 1、构造函数

```
var reg=new RegExp('/[0-9]/','g')
var reg new RegExp('\\bis\\b','g')
```

正则表达式中\，如果用字符串构建时，需要转义；如：要匹配点（.）正则表达式就是 `\.`, RegExp 的参数就是`RegExp('\\.')`

## 2、字面量

`var reg = /[0-9]/g;`

- g:global ,全文搜索，默认搜索到第一个结果结束
- i:ignore case ,忽略大小写，默认大小写敏感
- m:multiple，d 多行搜索

## 3、元字符：

在正则表达式中具有特殊意义的专有字符 如：( [ { \ ^ $ | ) ? \* + .

- 字符类
  [ a b c ] --- one of
  [ ^ a b c ] --- none of
- 范围类
  [ a - z ] --- a to z 闭区间

## 4、预定义特殊字符

- \t: 水平制表符
- \r: 回车符
- \n: 换行符
- \f: 换页符
- \cX: 与 X 对应的控制字符
- \v: 垂直制表符
- \0: 空字符

## 5、字符类

我们一般使用一个字符类`[ ]`来构建一个简单的字符类，字符类：就是符合某些特征的对象是一个泛指，而不是特指某个字符。如`[ abc ]`把 a 或者 b 或者 c 作为一类，用来匹配符合这类的字符。`[ ^abc ]`则表示不符合这类

## 6、范围类

我们可以用 `x-y` 来链接两个字符串表示从 x 到 y 的任意字符串，是个闭区间

## 7、预定义类

| 字符 | 等价类            | 含义           |
| ---- | ----------------- | -------------- |
| .    | [ ^\n\r ]         | 除了回车和换行 |
| \d   | [ 0-9 ]           | 数字字符       |
| \D   | [ ^0-9 ]          | 非数字字符     |
| \s   | [ \t\n\x0B\f\r ]  | 空白符         |
| \S   | [ ^\t\n\x0B\f\r ] | 非空白符       |
| \w   | [ a-zA-Z_0-9]     | 单词字符       |
| \W   | [ ^a-zA-Z_0-9]    | 非单词字符     |

## 8、边界

常用的边界匹配字符

- ^ ：以 xx 开头
- $ ：以 xx 结尾
- \b：单词边界，指[ a-zA-Z_0-9]之外的字符
- \B：非单词边界

**注**：单词边界就是一个词不被另外一个词跟随的位置或者不是另一个词汇字符前边的位置。如：\bo\b 只能匹配 o 前后都没有字符，前后只能是[ a-zA-Z_0-9]之外的字符。\bo\B 匹配的就是 o 前面是[ a-zA-Z_0-9]之内字符，后面是[ a-zA-Z_0-9]之外字符
**注**：一个匹配的词的边界的内容的长度是 0，\w\b\w 不能匹配任何字符串。

9、量词

- ？：最多出现一次
- - ：至少出现一次
- - ：任意次
- { n } ：出现 n 次
- { n , m } ：至少 n 次，至多 m 次
- { n, } ：至少 n 次
- { ,m } ： 至多 m 次
  例：/\d+\.\d{1,3}/ 匹配三位小数点的数字

## 10、贪婪模式 与 非贪婪模式

- 贪婪模式：对于一些量词，按照可以匹配的最大的量来匹配。"123456789".match(/\d{3,5}/g)--->["12345", "6789"]
- 非贪婪模式：即按照可以匹配的最小来匹配。"123456789".match(/\d{3,5}?/g)--->["123", "456", "789"]
- 非贪婪模式就是懒惰模式，如果需要匹配组 replace(/%(.\*?)%/g, `<span class="red">$1</span>`) 替换%...%部分

## 11、分组

如果我们需要匹配一定数量的某一字符串而不是单个字符，我们就需要把这个字符串作为整体，那么就需要对其分组。
例：(ab){4} --->匹配 ab 出现 4 次的字符串(abababab)
也可以通过 (ab|cd){4} 来达到或的功能
"2016-09-17".replace( /(\d{4})-(\d{2})-(\d{2})/g , "$2-$3-$1" );

- (pattern) ：匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在 VBScript 中使用 SubMatches 集合，在 JScript 中则使用$0…$9 属性。要匹配圆括号字符，请使用“\(”或“\)”。
- (?:pattern) ：非获取匹配，匹配 pattern 但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
- (?=pattern) ：非获取匹配，正向肯定预查，在任何匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
- (?!pattern) ：非获取匹配，正向否定预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
- (?<=pattern) ：非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。“(?<=95|98|NT|2000)Windows”目前在 python3.6 中 re 模块测试会报错，用“|”连接的字符串长度必须一样，这里“95|98|NT”的长度都是 2，“2000”的长度是 4，会报错。
- (?<!pattern) ：非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题，此处用或任意一项都不能超过 2 位，如“(?<!95|98|NT|20)Windows 正确，“(?<!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?<!2000)Windows 正确匹配。同上，这里在 python3.6 中 re 模块中字符串长度要一致，并不是一定为 2，比如“(?<!1995|1998|NTNT|2000)Windows”也是可以的。

## 12、前瞻 （\*重要）

- a(?=b): ---> 匹配后面紧跟着 b 的 a，如果有，则得到的结果是 a
- a(?!b): ---> 匹配后面没有紧跟着 b 的 a，如果有，则得到的记过是 a
- (?=b)a: ---> 匹配前面紧跟着 b 的 a，如果有，则得到的结果是 a
- (?!b)a: ---> 匹配前面没有紧跟着 b 的 a，如果有，则得到的记过是 a

# 13、RegExp 对象方法

- compile 编译正则表达式
- exec 检索字符串中指定的值，返回其位置
- test 检索字符串中指定的值，返回 true\false

调用非全局的 RegExp 对象的 exec()时，返回数组
第一个元素是与正则表达式相匹配的文本
第二个元素是与 RegExpObject 的第一个子表达式相匹配的文本（如果有）
第三个元素是与 RegExpObject 的第二个子表达式相匹配的文本（如果有），以此 类推

# 14、支持正则表达式的 String 对象方法

- search ：检索与正则表达式相匹配的值，返回匹配检索到索引，-1 表示没有检索到
- match ：找到一个或多个正则表达式的匹配，返回数组，内容包括检索内容，索引值，输入值等
- matchAll ：找到一个或多个正则表达式的匹配，返回数组，内容包括检索内容，索引值，输入值等，正则表达式需要带上`g`
- replace ：替换与正则表达式匹配的串，返回新的字符串，内容为替换后结果
- split ：把字符串分割为字符串数组，返回新的数组，内容为分割后结果

  Search：返回第一个匹配结果，有返回 index，没有查找到返回-1。不执行全局查找。对参数会强转正则对象
  Match : 全局调用（带 g），会返回匹配结果的数组，不会执行子表达式（分组）。非全局调用和 exec 返回一样。

```
String.prototype.replace( str , destStr );
String.prototype.replace( reg , destStr );
String.prototype.replace( reg , function );
'a1b2c3d4e5'.replace( /\d/g , function( match , index , origin ){
  console.log(index);
  return parseInt(match)+3;
})
'a1b2c3d4e5'.replace( /(\d)(\w)(\d)/g , function( match , group1 , group2 , group3 , index , origin ){
  console.log(match);
  return group1 + group3;
})
```

## 工具

- https://regex101.com/: 非常棒很推荐
- https://regexper.com/: 图形化正则表达式
